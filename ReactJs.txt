* React is a Javascript library, developed in 2013 by Jordan Walke of Facebook.
* Redux is framework agnostic. Learn it once, use it everywhere (Vue JS, Angular)

* So what are the alternatives for managing the state of a React component?
Redux is one of them.
State is so pervasive and hard that state management in JS is still an unsolved problem.

Redux helps giving each React component the exact piece of state it needs.
Redux holds up the state within a single location.
Also with Redux the logic for fetching and managing the state lives outside React.

* In a React component the state holds up data and the component might render such data to the user.
The state could also change in response to actions and events: in React you can update the local component’s state with setState.

* state.authentificationReducer
lorsque cette propriété(authentificationReducer) d’état change, mon composant prop est également modifié.

* Avec Redux, on distingue 2 catégories de composants : les composants de présentation et les composants conteneurs. 

		| Presentational Components		| Container Components
--------------------------------------------------------| --------------------------------------
Objectif	| Aspect extérieur(markup, styles)	| Fonctionnement (récupération de
		| de l'appli				| données, mise à jour de l'état) de l'appli
----------------| --------------------------------------|----------------------------------------
Utilise		| Non					| Oui
Redux
----------------| --------------------------------------| -----------------------------------------
Lecture des 	| Lecture depuis les props		| Abonnement au state de Redux
données	
----------------| --------------------------------------| ----------------------------------------
Pour changer 	| Appeler des callbacks depuis les	| Envoyer des actions Redux
les données	| props
----------------| --------------------------------------| ---------------------------------------
Est écrit	| A la main				| Souvent généré par React Redux
----------------| ----------------------------------------| ---------------------------------------

* Les actions
une action au sens Redux:
  Actions -> Reducers	-> Store
	<-	View	<-
Les actions envoient les données de l’application vers un store. Ce sont les seules sources d’information pour 
un store. Elles sont définies comme un objet Javascript qui a une propriété ‘type’ pour indiquer le type d’action réalisé
Les actions sont envoyées aux Reducer par la fonction dispatch();

* Les Reducers
Le reducer est une fonction pure (sans état) qui prend en entrée le précédent state et une action pour retourner
 en sortie le prochain state. (previousState, action) => newState
Passing an initial state is useful for server side rendering. Anyway, the state comes from reducers.

* Exression
 connect((...)) : il connecte le state de l'application avec les props du component.

* Ne pas récupérer tout le store
Ex:
const mapStateToProps = state => ({
  favoritesFilm: state
})
ici, on a connecté tout le state de l'application à un component spécifique. C'est pas bien car par exemple pour le
component Film, il va tout récupérer , les infos des utilisateurs, etc....

Cela m'amène à une autre bonne pratique. Quand vous mappez le state de l'application à un component, vous devez 
spécifier les informations qui vous intéressent et ne pas retourner tout le state.
const mapStateToProps = state => ({
  favoritesFilm: state.favoritesFilm
})
Ici, on n'a mappé que ce qui nous intéresse, à savoir la liste des films favoris.

* Il y a deux actions qui peuvent pousser un component à se re-rendre (UI refresh):
- un changement dans son state(avec setState())
- un changement dans ses props

* But what is the state anyway?
Consider the following example:
the user clicks a button, a modal appears afterwards.
We could describe the initial state as a plain JavaScript object:
var state = {
  buttonClicked: 'no',
  modalOpen: 'no'
}
And when the user clicks the button we have:
    var state = {
      buttonClicked: 'yes',
      modalOpen: 'yes'
    }

* NavLink vs <a> tag
NavLink devient <a href="#....."   />
Avec <a> tag si tu n'a pas de # , il va interroger le serveur.

*   
<Route path="/applicationcst/:saConsommateur" component={GetAppContainer} />

 this.state = {
      SaConsommateur: "",
    };

dans Render()
 <NavLink to={`/applicationcst/${this.state.SaConsommateur}`}>
              <input type="button" className="btn--success" value="Go" />
            </NavLink>
Il doit y avoir un mécanisme qui permet de renseigner this.state.SaConsommateur , genre handleChanged event.

Récupérer saCon dans le componennt applicationcst:
const saConso = this.props.match.params.saConsommateur;

* JSX is a preprocessor step that adds XML syntax to JavaScript. You can definitely use React without JSX but JSX makes 
React a lot more elegant. Just like XML, JSX tags have a tag name, attributes, and children

* Syntaxe JSX
- sytaxe basique: 
var element =  <div>Hello World</div>;
- Le composant avec une variable
var HelloUser = () => {
  var user = 'Gaël';
  return <div>Hello {user}!</div>;
};
Pour utiliser du JavaScript dans du JSX, il faut l’inclure entre { }.
- Le commentaire
 {/* Je suis un commentaire JSX */}
- Insérer un composant React dans du JSX
//1er composant
var Hello = () => {
  return <p>Hello</p>;
};
	
//2ème composant
var User = () => {
  var user = 'Gaël';
  return <span>{user}</span>;
};
//1er composant + 2ème componsant = un 3ème composant
var HelloUser = function() {
return (
 <div>
   <Hello />
   <User />
 </div>
)};
On peut voir dans ces exemples que tous les composants React commencent par des majuscules, c’est voulu car… obligatoire :-). Sans ça, React va penser qu’il s’agit d’un tag HTML standard.
- Un composant React recevant des props
var User = (props) => {
 var user = props.name;
 return <span>{user}</span>;
};
Il reçoit maintenant un argument props qui contient un attribut name.
Mais comment créer en JSX un composant HelloUser et lui passer l’argument User ?
//Rappel du composant Hello
var Hello = () => {
  return <span>Hello</span>;
};
var HelloUser = () => {
  return (
    <div>
      <Hello />
      <User name='Gaël' />
    </div>
  );
}
En faisant ça, l’objet { name : 'Gaël' } est passé en argument à la fonction qui crée le composant User.

- Un composant React et ses “children”
var Hello = function(props) {
	return <div>Hello {props.children}</div>
};
On peut se dire, à juste titre avec ce que l’on vient de voir, que l’on voit le composant Hello de la façon suivante :

<Hello children={/* QUELQUE CHOSE */} />
mais en réalité, on a ça :
<Hello>
  <span>John</span>
</Hello>
On découvre donc une nouvelle façon de manipuler le JSX :
<MonComposant> {/*DU JSX ICI*/} </MonComposant>
* React elements are immutable. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.
React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.

* functions components = literally Javascript functions
You can also use an ES6 class to define a component:
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
=
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
The above two components are equivalent from React’s point of view.

* Props are Read-Only
Whether you declare a component as a function or a class, it must never modify its own props.

* Adding Lifecycle Methods to a Class
 it’s very important to free up resources taken by the components when they are destroyed.
whenever the Clock component is rendered to the DOM for the first time. This is called “mounting” in React.
whenever the DOM produced by the Clock component is removed. This is called “unmounting” in React.
      componentDidMount(){}
      componentWillUnmount(){}
These methods are called “lifecycle methods”.
The componentDidMount() method runs after the component output has been rendered to the DOM.

* USING STATE CORRECTLY
There are three things you should know about setState().
- Do Not Modify State Directly
// Wrong
this.state.comment = 'Hello';
// Correct
this.setState({comment: 'Hello'});
The only place where you can assign this.state is the constructor.
- State Updates May Be Asynchronous
React may batch multiple setState() calls into a single update for performance. Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.
// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});
To fix it, use a second form of setState() that accepts a function rather than an object.
// Correct
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
- State Updates are Merged
When you call setState(), React merges the object you provide into the current state.
You can update them independently with separate setState() calls.

* React events are named using camelCase, rather than lowercase.
With JSX you pass a function as the event handler, rather than a string.
For exemple
<button onclick="activateLasers()">
  Activate Lasers
</button>
is slightly different in React:
<button onClick={activateLasers}>
  Activate Lasers
</button>
When using component class ES6, a common pattern is for an event handler to be a method on the class.
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};
    // In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.
    // This binding is necessary to make `this` work in the callback
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}

ReactDOM.render(
  <Toggle />,
  document.getElementById('root')
);

* If calling bind in contructor annoys you, there is a way you can get around this: by using  public class fields syntax
class LoggingButton extends React.Component {
  // This syntax ensures `this` is bound within handleClick.
  // Warning: this is *experimental* syntax.
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}

* CONDITIONAL RENDERING
Use javascript operators like if or the conditional operator.
Two ways to implement conditional rendering
 - create two components, then create third components which take a argument props like a flag and decide which component to display.
 function UserGreeting(props) {
  return <h1>Welcome back!</h1>;
 }

 function GuestGreeting(props) {
  return <h1>Please sign up.</h1>;
 }

 function Greeting(props) {
   const isLoggedIn = props.isLoggedIn;
   if (isLoggedIn) {
     return <UserGreeting />;
   }
   return <GuestGreeting />;
 }
ReactDOM.render(
  // Try changing to isLoggedIn={true}:
  <Greeting isLoggedIn={false} />,
  document.getElementById('root')
);

 - Using Element Variables (adapted for component using class ES6)
You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn’t change.
    let button;

    if (isLoggedIn) {
      button = <LogoutButton onClick={this.handleLogoutClick} />;
    } else {
      button = <LoginButton onClick={this.handleLoginClick} />;
    }

    return (
      <div>
        <Greeting isLoggedIn={isLoggedIn} />
        {button}
      </div>
    );
Expression: we will create a stateful compoment, this means a component with this.state defined